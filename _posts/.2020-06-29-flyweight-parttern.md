---
layout: post
title: "플라이웨이트(Flyweight) 패턴 Feat.Java"
tags: [Java, Design Pattern, Flyweight Pattern, Structural Pattern]
date: 2020-06-29
comments: true
---



<br>

# OverView

이번시간엔 구조패턴 중 하나인 플라이웨이트 패턴에 대해서 알아보도록 하겠다!

# 플라이웨이트(Flyweight) 패턴

플라이웨이트 패턴은 **응용프래그램이 대량의 객체를 사용해야 할 때 사용**한다. 플라이웨이트 패턴을 이해하기 이전에 객체 자체의 intrinsic(본질적인 개념, 내부), extrinsic(부가적인 개념, 외부) 에 대해서 이해해야한다. 

intrinsic은 곧 객체의 본질적인 개념을 뜻하는데 이 특성들은 다른 객체들과 공유될 수 있지만 extrinsic, 부가적인 개념은 다른 객체들과 공유될 수 없다. 예를 들어 스타크래프트 프로토스 유닛 중 질럿을 생각해보자. 최대 hp, 최대 armor, 공격력 등은 공유가 가능하지만 현재 질럿이 위치한 w, y 좌표, 현재 hp 값, 현재 armor 값 등등은 공유가 불가능한 상태이다.

이런 플라이웨이트 패턴을 사용하면 공유 가능한 객체별 본질적 상태의 양을 줄일 수 있고 더 많이 공유될 수록 인스턴스를 절약하는 효과를 가져온다. 



# 프로토스 유닛 생성하기

프로토스 유닛만의 공통 인터페이스를 구성하고 각각 개별 상태를 가진 질럿, 드라군, 다크템플러, 하이템플러를 생성하면서 플라이웨이트 패턴으로 공유 객체를 풀어가도록 해보겠다.



## 인터페이스 작성하기

코드의 중복을 없애기 위해 추상클래스로 인터페이스를 작성했다.

**GatewayUnit.java**

```java
package me.sup2is;

public abstract class GatewayUnit {

    int maxHp;
    int maxArmor;
    int power;
    Status status;

    public GatewayUnit(int maxHp, int maxArmor, int power) {
        this.maxHp = maxHp;
        this.maxArmor = maxArmor;
        this.power = power;
    }

    public abstract void attack();
    public void status() {
        System.out.println(getClass().getSimpleName() + " 현재 위치(x, y): " + status.currentX + " : " + status.currentY + ", 현재 상태(hp, armor): " + status.currentHp + " : " + status.currentArmor);
    }
}

class Status {

    int currentX;
    int currentY;
    int currentHp;
    int currentArmor;

    public Status(int currentX, int currentY, int currentHp, int currentArmor) {
        this.currentX = currentX;
        this.currentY = currentY;
        this.currentHp = currentHp;
        this.currentArmor = currentArmor;
    }
}

```

GatewayUnit 클래스는 최대hp, 최대 armor, 공격력 필드와 현재 좌표나 상태값을 나타내는 Status 타입의 변수가 있다. 해당 유닛의 최대hp, 최대 armor, 공격력은 공유 가능하게 설계했으므로 인스턴스 생성 시점에 초기화 하도록 구성했다.

이제 GatewayUnit를 클래스를 구현하는 Zealot 클래스를 확인해보자.

**Zealot.java**

```java
package me.sup2is;

public class Zealot extends GatewayUnit {

    public Zealot(int maxHp, int maxArmor, int power) {
        super(maxHp, maxArmor, power);
    }

    @Override
    public void attack() {
        System.out.println(getClass().getSimpleName() + "! 근거리 공격");
    }

}

```

별다른 특이점은 없고 나머지 Dragon, Dark Templar, High Templar 역시 마찬가지로 구성한다.

## Gateway 작성하기

```java
package me.sup2is;

import java.util.HashMap;
import java.util.Map;

public class Gateway {

    private static Map<UnitType, GatewayUnit> map = new HashMap<>();

    public static GatewayUnit getUnit(UnitType unitType) {

        GatewayUnit gatewayUnit = map.computeIfAbsent(unitType, u -> {

            GatewayUnit g = null;

            switch (unitType) {
                case ZEALOT:
                    g = new Zealot(50, 50, 10);
                    break;
                case DRAGON:
                    g = new Dragon(75, 50, 10);
                    break;
                case DARKTEMPLAR:
                    g = new DarkTemplar(50, 50, 20);
                    break;
                case HIGHTEMPLAR:
                    g = new HighTemplar(25, 75, 0);
                    break;
            }

            return g;
        });

        return gatewayUnit;
    }
}

```

이 Gateway 클래스는 팩토리 메서드를 제공해서 타입이 map 인스턴스에 존재하지 않는다면 미리 설정된 값으로 인스턴스를 찍어내는 역할을 한다. 싱글톤 패턴과 매우 유사하다. 이런식으로 구성하면 객체의 본질적인 부분은 최초 생성시점부터 공유되도록 구성할 수 있다.

실제 사용해보자.

## 유닛 생성하기

**Main.java**

```java
package me.sup2is;

public class Main {

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            for (UnitType u: UnitType.values()) {
                GatewayUnit unit = Gateway.getUnit(u);
                unit.status = new Status(getRandom(), getRandom(), getRandom(), getRandom());
                unit.status();
            }
        }
    }

    private static int getRandom() {
        return (int)(Math.random()*100 );
    }

}

```

유닛을 생성하고 별도로 status 변수를 초기화시켜줌으로써 부가적인 요소 연산을 지정해줬다. 결과를 확인해보자.



```
Zealot 현재 위치(x, y): 11 : 46, 현재 상태(hp, armor): 10 : 87
Dragon 현재 위치(x, y): 54 : 82, 현재 상태(hp, armor): 69 : 43
DarkTemplar 현재 위치(x, y): 3 : 80, 현재 상태(hp, armor): 68 : 72
HighTemplar 현재 위치(x, y): 90 : 10, 현재 상태(hp, armor): 42 : 52
Zealot 현재 위치(x, y): 63 : 84, 현재 상태(hp, armor): 48 : 81
Dragon 현재 위치(x, y): 98 : 56, 현재 상태(hp, armor): 71 : 20
DarkTemplar 현재 위치(x, y): 14 : 98, 현재 상태(hp, armor): 94 : 37

...

Dragon 현재 위치(x, y): 50 : 32, 현재 상태(hp, armor): 3 : 15
DarkTemplar 현재 위치(x, y): 96 : 7, 현재 상태(hp, armor): 63 : 12
HighTemplar 현재 위치(x, y): 13 : 63, 현재 상태(hp, armor): 49 : 52
Zealot 현재 위치(x, y): 80 : 77, 현재 상태(hp, armor): 12 : 17
Dragon 현재 위치(x, y): 45 : 12, 현재 상태(hp, armor): 31 : 71
DarkTemplar 현재 위치(x, y): 11 : 36, 현재 상태(hp, armor): 0 : 42
HighTemplar 현재 위치(x, y): 0 : 17, 현재 상태(hp, armor): 58 : 2
```







# 마무리

조금 급하게 구성한 감이 없지 않아 있어서 예제가 조금 허술하다.. (하이템플러가 `attack()` 메서드를 구현하는 등) 하지만 FlyweighFactory 역할을 하는 Gateway의 역할만 중점적으로 확인하면 Flyweigh 패턴을 이해하는것에 무리는 없을것 이라고 생각한다.

그리고 이패턴에 대해서 조금 궁금한게 레퍼런스 참조이기때문에 최초에 들어간 부가적인요소(xy 좌표 등)은 그대로 map 인스턴스에 존재한다. 아마 내











<hr>
포스팅은 여기까지 하겠습니다. 퍼가실때는 출처를 반드시 남겨주세요!

예제: [https://github.com/sup2is/study/tree/master/design-pattern/decorator-pattern](https://github.com/sup2is/study/tree/master/design-pattern/decorator-pattern)

<br>

**References**

- GoF의 디자인 패턴 - 에릭 감마, 리처드 헬름, 랄프 존슨, 존 블리시디스
- [https://johngrib.github.io/wiki/decorator-pattern/](https://johngrib.github.io/wiki/decorator-pattern/)
- [https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm](https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm)