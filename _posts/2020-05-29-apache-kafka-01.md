---

layout: post
title: "Apache Kafka 시작하기"
tags: [Apache Kafka]
date: 2020-05-29
comments: true
---



<br>

# OverView



![apache kafka](https://kafka.apache.org/images/logo.png)

<br>

Apache Kafka는 2011년 링크드인에서 시작한 오픈소스 소프트웨어이다. 초기에 링크드인 웹 사이트에서 생성되는 로그를 처리하여 웹 사이트 활동을 추적하는 것을 목적으로 개발되었다. 

Apache Kafka는 **여러 대의 분산 서버에서 대량의 데이터를 처리하는 분산 메시징 시스템**이다. 메시지를 받고 받은 메시지를 다른 시스템이나 장치에 보내기 위한 목적으로 사용한다.

요즘에 정말 많이사용하는 Apache Kafka는 이제 더이상 옵션이 아니라 필수로 다가오는 것 같다 이 Apache Kafka에 대해서 자세하게 알아보자!

<br>

![apache kafka](https://kafka.apache.org/images/kafka_diagram.png)

# Kafka의 탄생목적

LinkedIn에서 Kafka를 개발하기 이전에도 비슷한 느낌의 Message Queue들이 오픈소스로 존재했는데 대표적인 오픈소스중에 하나로 **Rabbit MQ** 또는 **Active MQ** 등을 뽑을 수 있다.

실제로 Rabbit MQ의 release note( https://www.rabbitmq.com/versions.html)를 보면 2007년에 1.0.0 버전이 릴리즈된 것을 확인할 수 있다.

그렇다면 왜 LinkedIn은 기존에 있던 RabbitMQ를 사용하지 않고 Kafka를 개발했을까? 

<br>

이전 시스템들의 강력한 메시지 전달 보장, Scale Out, 메시지를 Disk에쓰는가? 아니면 Memory에 쓰는가? 등의 다양한 이유가 있지만 Kafka의 존재이유는 **매우 높은 처리량**에 있다.  전세계 사용자들의 로그데이터를 분산환경에서 적절하게 처리해야했기 때문에 이전시스템들보다 조금 더 좋은 성능의 아키텍쳐가 필요했던 것이다.

# LinkedIn의 Kafka 실현 목표

LinkedIn은 다음과 같이 Kafka의 실현 목적을 정의했다.

1. 높은 처리량으로 실시간 처리
   - 전 세계 사용자들의 방대한 액세스 로그를 감당하기위해 매우 높은 처리량을 필요로 한다.
2. 임의의 시간에 데이터를 읽기
   - 메시지를 단순히 실시간 처리 뿐만 아니라 임의의 시간에 읽어들일 수 있도록 메시지를 Memory에 저장하지 않고 Disk에 저장시키도록 한다.
3. 다양한 제품과 시스템에 쉽게 연동
   - 이용 목적에 따라 DB, 데이터웨어하우스 등의 보다 쉬운 API를 제공해서 손쉬운 연결을 하도록 한다.
4. 메시지 손실방지
   - Kafka 서버가 갑작스럽게 종료되더라도 Replication을 통해 메시지가 손실되는 것을 방지하도록 한다.

# Kafka 기본 시스템 구성

kafka를 사용하는 애플리케이션의 기본적인 구성은 다음과 같다.

![](https://user-images.githubusercontent.com/30790184/83240069-cd22c200-a1d3-11ea-8684-413d4192c156.png)



- **브로커:** 하나의 서버로 올라가고 이 브로커를 카프카 서버로 봐도 무방할 것 같다. 브로커들을 모아서 클러스터링을 구성하여 성능 확장을 할 수 있고 브로커에서 받은데이터는 전부 영속화가 이루어지기 때문에 장기 보관이 가능하다.
- **메시지:** 카프카에서 다루는 데이터의 최소 단위이다.
- **프로듀서:** 데이터를 생산하는 생산자이며 브로커에게 메시지를 보내는 애플리케이션을 가르킨다.
- **컨슈머:** 브로커에게서 메시지를 소비하는 애플리케이션을 가르킨다.
- **토픽:** 메시지를 종류별로 구분할 수 있는 스토리지개념, 토픽은 브로커에 배치되어서 관리되고 프로듀서는 이 토픽에 데이터를 전송하고 컨슈머는 이 토픽에서 데이터를 소비한다.
- **주키퍼:** 카프카의 브로커에 있어서 분산 처리를 위한 관리 도구로 apache zookeeper를 사용한다. 때문에 카프카 서버를 구성하기 위해 현재로써는 주키퍼 서버가 필수로 구동되어야 한다.



# Kafka 분산 메시징 구성

- **파티션:** 토픽에 대한 대량의 메시지 입출력을 지원하기 위해서 브로커 내부에는 파티션이라는 개념을 도입했다. 하나의 토픽에는 여러개의 파티션을 구성할 수 있고 이 파티션은 카프카 클러스터 내부에서 분산되어 성능 확장 또한 가능하다. 이런 파티션은 컨슈머 그룹의 컨슈머 개수와 매칭되어 병렬 분산 처리를 가능하게 해준다.
- **컨슈머 그룹:** 컨슈머를 그룹화시켜서 토픽내부의 파티션의 개수에 따라 병렬 분산 처리를 가능하게 해주는 개념이다.
- **오프셋:** 각 파티션 단위로 메시지 위치를 나타내는 정보로 오프셋이라는 개념이 있다. 컨슈머가 메시지를 올바르게 소비했다면 오프셋 커밋을 해서 소비한 메시지의 범위와 실패시 재시도를 제어한다.



![](https://gerardnico.com/_media/dit/kafka/log_consumer.png?w=400&tok=00808d)

# Kafka의 복제 구조

앞서 설명한 카프카의 실현 목적에서 **메시지 손실방지**는 카프카 내부의 레플리카라는 개념으로 구현이 되었다.

![](https://static1.squarespace.com/static/56894e581c1210fead06f878/t/5b8bf33bcd8366d4a0159508/1535898444327/KafkaPartitions.PNG?format=1500w)

파티션은 단일 또는 여러개의 레플리카로 구성되고 여러 레플리카 중 한개는 Leader이고 나머지는 Follower이다.

Leader 레플리카의 복제 상태를 유지하고 있는 레플리카는 In-Sync Replica로 분류되고 보통 ISR로 줄여서 사용한다. 이 ISR들은 비동기로 계속적인 복제를 유지해서 메시지의 손실을 최소화 시켜준다.

<br>



<hr>

포스팅은 여기까지 하겠습니다. 퍼가실때는 출처를 반드시 남겨주세요!

<br>

**References**

-  실전 아파치 카프카 - 사사키 도루 등 6명 (한빛미디어)
