---
layout: post
title: "JUnit5의 Class Order 기능 활용하기"
tags: [Spring Boot, JUnit5]
date: 2022-03-03
comments: true
---

<br>

# Overview

오랜만에 쓰는 글이다. 이번 시간에는 JUnit5의 Class Order기능에 대해 알아보고 Spring Test Context에서 어떻게 활용하면 좋을지에 대해 알아보도록 하자.



# JUnit5의 Method Order

JUnit5의 Class Order를 살펴보기 전에 Method Order도 확인해보자.

테스트들은 기본적으로 의존관계가 없어야하고 한 메서드는 하나의 기능만 테스트해야한다. 하지만 실전에서는 통합테스트나 순서가 필요한 기능 테스트들이 의존관계로 엮여 있는 경우가 많다.

기본적으로 Junit은 Method Order만 제공했고 아래와 같은 형태로 많이 사용했다.

```java
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class OrderedTests {

  @Test
  @Order(1)
  void nullValues() {}

  @Test
  @Order(2)
  void emptyValues() {}

  @Test
  @Order(3)
  void validValues() {}
}
```

위에서 사용한 `@TestMethodOrder` 는 아래와 같은 모습을 갖고 있다.

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@API(status = STABLE, since = "5.7")
public @interface TestMethodOrder {

	/**
	 * The {@link MethodOrderer} to use.
	 *
	 * @see MethodOrderer
	 * @see MethodOrderer.MethodName
	 * @see MethodOrderer.DisplayName
	 * @see MethodOrderer.OrderAnnotation
	 * @see MethodOrderer.Random
	 */
	Class<? extends MethodOrderer> value();

}

```

`MethodOrderer` 타입은 위에서 설명된것과 같이 `MethodOrderer.MethodName`, `MethodOrderer.DisplayName`, `MethodOrderer.OrderAnnotation`, `MethodOrderer.Random` 이고 직관적이기 때문에 따로 설명은 필요 없을 것 같다. 

실제로 `MethodOrderer` 인터페이스를 살펴보면 구현체들을 확인할 수 있다. 필요하다면 커스텀형태로 사용해도 되는데 그럴만한 경우는 따로 없을 것 같다.

클래스마다 지정하지 않고 기본값을 지정하고싶다면 `src/test/resources/junit-platform.properties`에 아래와 같은 형태로 적어주면 기본값을 설정할 수 있다.

```properties
junit.jupiter.testmethod.order.default = \
    org.junit.jupiter.api.MethodOrderer$OrderAnnotation
```

# JUnit5의 Class Order

위에서 설명한 JUnit5의 Method Order 기능은 2020년 9월 5.7버전 release note에 포함되어 있다. 이번에 설명할 JUnit5의 Class Order 기능은 5.8 버전에 포함되었고 5.8 버전은 2021년 9월에 release되었다.

- 5.7 release note : [https://junit.org/junit5/docs/5.7.0/release-notes/index.html#release-notes-5.7.0](https://junit.org/junit5/docs/5.7.0/release-notes/index.html#release-notes-5.7.0)
- 5.8 release note : [https://junit.org/junit5/docs/current/release-notes/index.html#release-notes-5.8.0](https://junit.org/junit5/docs/current/release-notes/index.html#release-notes-5.8.0)

위에서 설명한것처럼 테스트는 기본적으로 의존 관계가 없어야하고 메서드를 포함한 클래스의 순서도 마찬가지다. 하지만 아래와 같은 경우 테스트의 순서를 의미있게 지정해서 이득을 볼 수 있다.

- 빠른 실패
- 병렬 환경에서 수행시간이 긴 테스트를 먼저 실행
- Spring 개발 환경에서 Integration 테스트와 Unit 테스트(Mocking을 활용한)가 뒤죽박죽 섞인 경우 Text Context의 장점을 제대로 활용하지 못할 때

첫번째 '빠른 실패'는 말 그대로 불안한 테스트를 빠르게 실패해서 사용자가 빠른 피드백을 얻게하거나 기타 등등의 효과를 얻을 수 있을 것 같다. 두번째 병렬 환경에서 수행시간이 긴 테스트를 먼저 실행하는 건 빠른 테스트를 위한 필수 요건이다.

세번째의 경우 아래에서 코드와 사례로 자세하게 설명하려고 한다.

Class Order 기능도 `ClassOrderer`를 구현해서 사용하면 된다. 기본 구현체는 아래와 같다. 자세한 설명은 생략한다.

- [ClassOrderer.ClassName](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.ClassName.html)
- [ClassOrderer.DisplayName](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.DisplayName.html)
- [ClassOrderer.OrderAnnotation](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.OrderAnnotation.html)
- [ClassOrderer.Random](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.Random.html)

적용하는 방법 역시 간단하다. `src/test/resources/junit-platform.properties` 안에 아래와 같은 형태로 설정할 수 있다.

```properties
junit.jupiter.testclass.order.default = \
    org.junit.jupiter.api.ClassOrderer$OrderAnnotation
```



# Spring에서 JUnit5 Class Order 활용하기

사실 이게 본론이다. 현재 회사에서 테스트의 종류는 아래와 같다.

1. **Spring을 사용하지 않는 테스트**
2. **Spring + @MockBean을 사용하는 테스트**
3. **only Spring만 사용하는 테스트**

나는 여러 책들을 읽으면서 얻은 "테스트는 외부 컴포넌트에 의존하면 안된다" 라는 원칙을 갖고 있기 때문에 Database, 외부 API 서버, 프레임워크 등등 테스트와 최대한 분리시키기 위해 'Spring을 사용하지 않는 테스트'를 기본으로 작성하려고 노력한다.

하지만 Spring restdocs를 사용하면 어쩔 수 없이 Spring 위에서 테스트를 올려야하는데 이 경우엔 'Spring + @MockBean을 사용하는 테스트'를 작성했었다.

추가로 통합테스트가 필요한 경우에는 Spring Context에 등록된 Bean들로만 구성해야하기 때문에 'only Spring만 사용하는 테스트' 역시 필요해 졌다.

<br>

아직 경험이 많지 않아서 그런지 모르겠지만 위에서 설명한 세가지 테스트는 모두 각자의 의미가 있고 애플리케이션에서 반드시 필요한 테스트라고 생각한다.

하지만 1번의 경우는 문제가 되지 않지만 2번과 3번을 섞어 쓰는 경우 문제가 생길 수 있다. 

## Spring의 Test Context Caching

Spring에서 Test Context가 ApplicationContext를 로드하면 해당 컨텍스트는 캐시된 상태로 동일한 테스트내에서 계속해서 재사용된다.   이런 특성을 잘 활용하면 무거운 Spring Test들을 효과적으로 수행해서 빠른 빌드&테스트를 수행할 수 있다.

하지만 `@MockBean` 을 사용하면 앞에서 설명한 **동일한 테스트** 라는 전제가 깨지게되는데 ... to be continue...







# 정리

Method Order 기능뿐만 아니라 Class Order 기능도 잘 활용하면 강력한 도구가 될 것 같다. 특히 Spring 환경에서 @MockBean + Test Context 활용에 대한 고민이 있다면 적용해 볼 것을 적극 추천한다!





<br>

***

포스팅은 여기까지 하겠습니다. 감사합니다!



<br>

**References**

-  [https://junit.org/JUnit5/docs/current/user-guide/#writing-tests-test-execution-order-classes](https://junit.org/JUnit5/docs/current/user-guide/#writing-tests-test-execution-order-classes)
-  [https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-caching](https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-caching)
